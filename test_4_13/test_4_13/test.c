#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//7.编程常见的错误
//7.1编译型错误
//直接看错误提示信息(双机)，解决问题。或者凭借经验就可以搞定。相对来说简单
//7.2链接型错误
//看错误提示信息，主要在代码中找到错误信息中的标识符，然后定位问题所在。一般是标识符名不存在或者拼写错误。
//7.3运行时错误
//借助调试，逐步定位问题。最难搞
//温馨提示：
//做一个有心人，积累排错经验


//编译型错误就是语法错误
//test.c(源文件)-----编译---------链接----->test.exe(可执行文件)
//在编译阶段发现的错误叫编译错误，在链接阶段发现的错误叫链接错误
//运行时错误 - 借助调试解决的错误
   
//int Add(int x, int y)
//{
//	return x + y;
//}
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = Add(a, b);
//	printf("%d\n", c);
//	return 0;
//}

//1.深度剖析数据在内存中的存储
//重点：
//1>数据类型详细介绍
//2>整型在内存中的存储：原码、反码、补码
//3>大小端字节序介绍及判断
//4>浮点型在内存中的存储解析

//1.数据类型介绍
//char   1个字节
//short  2个字节
//int    4个字节
//long   4或8个字节
//long long  8个字节
//float  4个字节
//double 8个字节

//类型的意义：
//1.使用这个类型开辟内存空间的大小(大小决定了使用范围），例如，定义一个人的年龄可以用short
//2.如何看待内存空间的视角,例如，一个float类型的数据决定了内存中放的都是一些小数，一个int类型的数据决定了内存中放的都是一些整数

//1.1类型的基本归类：
//整型家族：
//char //char 虽然是字符类型，但是字符类型存储的时候，存储的字符的ASCALL值是整数
//    unsigned char
//    signed char
//short                          //short s1;//有符号的，等价于//signed short s2;
//    unsigned short [int]       //unsigned short s3;//无符号的
//    signed short [int]  //方括号可以省略
//int
//    unsigned int
//    signed int
//long 
//    unsigned long [int]
//    signed long [int]

//生活中有一些数据是带正负的，比如温度，所以有符号的数据可以存放在有符号的变量中。但是有一些数据是没有负数的，例如年龄，所以就需要将它定义为无符号变量

//short - 2byte - 16bit,如果是有符号数据，最高位是符号位，最高位是0，表示这正数，最高位是1，表示负数。对于无符号数来说最高位是数据位

//直接写short、int、long表示有符号的，但是直接写char不能判断出是有符号还是无符号，char有无符号取决于编译器，大部分编译器中char就是signed char



//浮点型家族： 
//float
//double
//long double


//构造类型：(自定义类型)
//数组类型
//>结构体类型struct
//>枚举类型 enum
//>联合 类型 union

//数组类型
//int arr[10];//arr的类型是：int [10]
//int arr2[4];//int [4]
//char arr[4];//arr的类型是：char [4]
////数组元素个数发生变化时类型也在发生变化


//指针类型
//int* pi;
//char* pc;
//float* pf;
//void* pv;
//指针变量是用来存放地址的，不同指针类型代表的意义也有所差异

//空类型
//void表示空类型(无类型)
//通常应用于函数的返回类型、函数的参数、指针类型

//void* p;
//void test(void)
//{
//
//}
//
//int main()
//{
//	return 0;
//}


//2.整型在内存中的存储
//一个变量的创建是要在内存中开辟空间的，空间的大小是根据不同的类型而决定的。

//数据在所开辟内存中是如何存储的，例如：
//int a = 20; //a分配4个字节的空间
//int b = -10;

//2.1原码、反码、补码
//计算机中的整数有三种表示方法，即原码、反码和补码
//三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位负整数的三种表示方法各有不同

//原码---直接将数值按照正负数的形式翻译成二进制就可以了
//反码---将原码的符号位不变，其他位依次按位取反就可以得到了
//补码---反码+1

//整数可以写出3种2进制表示形式：
//原码
//反码
//补码
//正整数的原反补相同
//负数的原反补是需要计算的
//int main()
//{
//	int a = 10;//整型值
//	//原码：00000000 00000000 00000000 00001010
//	//反码：00000000 00000000 00000000 00001010
//	//补码：00000000 00000000 00000000 00001010
//
//	int b = -10;//整型值
//	//原码：10000000 00000000 00000000 00001010
//	//反码：11111111 11111111 11111111 11110101
//	//补码：1111 1111 1111 1111 1111 1111 1111 0110
//	//      F     F    F    F    F    F    F   6
//	//转换成16进制：0xff 0xff ... 0xf6
//	//经过编译调试发现b在内存中存的是补码
//	return 0;
//} 


//2进制  0~1
//8进制  0~7
//10进制 0~9
//16进制 0~9  a~f

//为什么内存中存储的是补码
//int main()
//{
//	//int a = 10;
//	1 - 1;
//	//CPU 只有加法器
//	//使用补码计算是正确的
//	//1+（-1）
//	//1:          00000000 00000000 00000000 00000001
//	//-1:         11111111 11111111 11111111 11111111
//	//1+（-1）   1 00000000 00000000 00000000 00000000//1丢失，得到0
//	//使用原码计算是错误的
//	//1：      00000000 00000000 00000000 00000001
//	//-1：     10000000 00000000 00000000 00000001
//	//1+（-1） 10000000 00000000 00000000 00000010
//	return 0;
//}

//二进制有符号表示范围0~127，-128 ~ -1
//而进制无符号位表示范围0 ~ 255

//int main()
//{
//	unsigned int ch = -10;
//	//-10
//	//10000000 00000000 00000000 00001010
//	//11111111 11111111 11111111 11110101
//	//11111111 11111111 11111111 11110110
//	printf("%u\n", ch); //4,294,967,286//%u是打印无符号数的，不是无符号数我也认为是无符号数
//	printf("%d\n", ch);//%d是来打印有符号数的，不是有符号数我也认为是有符号数
//	return 0;
//}


//int main()
//{
//	int a = 0x11223344; //在内存中是倒着存的44332211
//	return 0;
//}

//11 22 33 44 
//大端字节序存储：---把一个数据低位字节处的数据存放在高地址处，把高位字节处的数据存放在低地址处
//11是最高位字 节的内容

//44 33 22 11
//小端字节序存储：---把一个数据高位字节处的数据存放在高地址处，把低位字节处的数据存放在低地址处

//为什么有大端小端？
//因为在计算机系统中，我们是以字节位单位的，每个地址单元都对应着一个字节，一个字节为8bit.

//设计一个程序来判断大小端
//int check_sys()
//{
//	int a = 1;
//	char* p = (char*)&a;
//
//	if (*p == 1)
//	{
//		return 1; //小端 
//	}
//	else
//	{
//		return 0; //大端
//	}
//}
//int main()
//{
//    int c = check_sys();
//	switch (c)
//	{
//	case 1:
//		printf("小端\n");
//		break;
//	case 0:
//		printf("大端\n");
//		break;
//	}
//	return 0;
//}

//简化代码
int check_sys()
{
	int a = 1;
	return *(char*)&a;
}
int main()
{
	int c = check_sys();
	switch (c)
	{
	case 1:
		printf("小端\n");
		break;
	case 0:
		printf("大端\n");
		break;
	}
	return 0;
}