#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//int main()
//{
//#include <string.h>
//	int main()
//	{
//		char a[1000];
//		int i;
//		for (i = 0; i < 1000; i++)
//		{
//			a[i] = -1 - i;
//		}
//		printf("%d", strlen(a)); //255
//		//
//		//strlen是求字符串的，找的'\0'的位置，统计的\0之前出现多少个字符
//		//'\0'的ASCII码值是0
//		//
//		return 0;
//	}
//	return 0;
//}

//unsigned char i = 0;
////无符号char的范围是0~255
//int main()
//{
//	int count = 0;
//	for (i = 0 ; i <= 255; i++)
//	{
//		count++;
//		printf("hello world\n");
//	}
//	//死循环，当i到255的时侯的二进制序列时是11111111 ，继续+1,就会变成00000000，因为char只能存8位，所以最高位有1溢出，故，得到的补码是00000000，转换为十进制是0，0符合循环条件所以死循环
//	//因为无符号char的范围是0~255，所以i不能超过这个范围，循环范围恒成立
//
//	//写代码时尽量少引用无符号数，因为容易 引发bug
//	printf("%d\n",count);
//	return 0;
//}



//3.浮点数在内存中的存储
//常见的浮点数：
//3.14159
//1E10 ----表示1.0*10^10
//浮点数家族包括：float,double,long double类型
//浮点数的表示范围：float.h中定义
//float.h 定义了浮点数的取值范围的相关信息
//limits.h 定义了整型数的取值范围的相关信息

//浮点数存储的例子：
//int main()
//{
//	int n = 9;
//	float* pFloat = (float*)&n; //int*
//	printf("n的值为：%d\n", n);  //9
//	printf("*pFloat的值为：%f\n", *pFloat);  //0.000000
//
//	*pFloat = 9.0;
//	printf("num的值为：%d\n", n); //1091567616
//	printf("*pFloat的值为：%f\n", *pFloat); //9.000000
//	return 0;
//}
//整数和浮点数在内存中的存储方式是有所差异的 

//3.2浮点数存储规则
//num和*pFloat在内存中明明是同一个数，为什么浮点数和整数的解读结果会差别这么大？

//要理解这个结果，一定要搞懂浮点数在计算机内部的表示方法
//详细解读：
//根据标准IEEE（电器和电子工程协会）754，任意一个二进制浮点数V可以表示成下面的形式：
//(-1)^S*M*2^E
//(-1)^S表示符号位，当	S=0，V为正数；当S=1，V为负数	
//M表示有效数字，大于等于1，小于2   
//2^E表示指数位


//举例来说：
//十进制的5.0,写成二进制是101.0，相当于1.01x2^2
//那么，按照上面V的格式，可以得出S=0，M=1.01，E=2
//十进制的-5.0，写成二进制是-101.0，相当于-1.01x2^2.那么，S=1，M=1.01，E=2.
//IEEE 754规定：
//对于32位的浮点数(float)类型，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M

//关于指数E的情形举例
int  main()
{
	float f = 5.5;
	//5.5的二进制码是101.1
	//(-1)^0*1.011*2^2
	//S = 0
	// E = 2    +127 = 129
	//M = 1.011
	//存储到内存：
	//16进制：0100 0000 1011 0000 0000 0000 0000 0000
	//         4    0    B   0     0    0    0    0
	//0X40B00000
	return 0;
}