#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//1.指针

//1>指针是什么
//2>指针和指针类型
//3>野指针
//4>指针运算
//5>指针和数组
//6>二级指针
//7>指针数组

//1>指针是什么
//指针是内存中一个最小单元的编号，也就是地址
//平时口语中的指针，通常指的是指针变量，是用来存放内存地址的变量
//总结：指针就是地址，口语中说的指针通常指的就是指针变量
//地址是为了快速找到一个内存单元的
//byte
//1KB = 1024 byte
//1MB = 1024KB
//1GB = 1024Mb
//指针大小在32为平台是4个字节，在64位平台是8个字节
//int main()
//{
//	int a = 10;
//	int* pa = &a;//pa是一个变量，专门用来存放地址的一个变量
//	return 0;
//}

//2>指针和指针类型
//int main()
//{
//	int a = 10;
//	int* pa = &a;
//
//	char ch = 'w';
//	char* pc = &ch;
//
//	printf("%d\n", sizeof (pa));
//	printf("%d\n", sizeof (pc));
//	return 0;
//}

//指针类型决定了，指针再被解引用的时候，访问的权限。
//整型指针解引用访问4个字节，字符指针解引用访问1个字节
//int main()
//{
//	int a = 0x11223344;
//	int* pa = &a;
//	*pa = 0;
//
//	return 0;
//}

//int main()
//{
//	int a = 10;
//	int* pa = &a;
//	char* pc = &a;
//  
//  //%p,打印地址
//	printf("%p\n", pa);//0135FE24
//	printf("%p\n", pc);//0135FE24
//
//	printf("%p\n", pa + 1);//0135FE28
//	printf("%p\n", pc + 1);//0135FE25
//	//指针类型决定了，指针向前或者向后走一步，走多大距离。
//	//int* +1--> +1*sizeof(int) ==+4
//	//char* +1--> +1*sizeof(char) ==+1
//	//int* +n--> +n*sizeof(int) ==+4n
//	//cha* +n--> +n*sizeof(char) ==+4n
//	return 0;
//}
//
//int main()
//{
//	int arr[10] = { 0 };
//	//如果希望按照一个整型的形式访问
//	int* p = arr;
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		*p = 0x11223344;
//		p++;
//	}
//	//如果希望，你访问这个40个字节的时候，是以字节为单位访问
//	//char* p = (char*)arr;//int*
//	//int i = 0;
//	//for (i = 0; i < 40; i++)
//	//{
//	//	*p = 'x'; //*p解引用
//	//	p++;
//	//}
//	return 0;
//}

//不管是二维数组还是一维数组，在传参的时候，都不会去创建数组，所以数组的大小不需要明确指定。

//一维数组传参的时候，形参的数组大小可以省略。
//二维数组传参的时候，形参的数组中，行可以省略，列不能省略。


//3>野指针
//野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）

//野指针成因
//1>指针未初始化
//int main()
//{
//	int* p;//局部变量指针未初始化，默认为随机值
//
//	*p = 20;
//	return 0;
//}

//2>指针越界访问
//int main()
//{
//	int arr[5] = { 1,2,3,4,5 };
//	int i = 0;
//	int* p = arr;
//	for (i = 0; i < 10; i++) //10超出了范围，所以5之后就变成了野指针
//	{
//		printf("%d ", *p);
//		p++; 
//	}
//	return 0;
//}

//3>指针指向的空间释放,会造成非法访问
//int* test()//a 出函数就销毁，但他的地址却还在*p中，所以在执行时可能出现越界现象。
//{
//	int a = 10;
//	printf("%d\n", a);
//	return &a;
//
//}
//int main()
//{
//	int*p = test();
//	*p = 100;
//	printf("%d\n", p);
//	printf("%p\n", *p);
//	return 0;
//}

//4>避免野指针出现，首先就要给指针初始化，例：
//int main()
//{
//	int a = 10; 
//	int b = &a;
//
//	int* q = NULL; //不知道指针指向哪里的时候就可以给赋初值，给q赋空值NULL就是为了使他在一定程度上变得安全。
//	//如果int* q = NULL;这个指针就不能在使用
//	if (q != NULL) //如果q != NULL，就可以继续使用
//	{
//		//....
//	}
//	return 0;
//}
//指针在不使用的时候就置为空


//4.指针运算 
//1>指针+-整数
//2>指针-指针
//3>指针的关系运算

//1>指针+-整数
//#define N_VALUES 5
//float values[N_VALUES];
//float *vp;
////指针+-整数：指针的关系运算
//for (vp = &values[0]; vp < &values[N_VALUES];)//指针的比较就是指针的关系运算
//{
//	*vp++ = 0;//将数组中的每个地址中元素都赋值为0
//}
//vp是地址，想拿到vp地址中的值的时候就要加*进行解引用（*vp)

//2>指针-指针
//前提：两个指针必须指向同一块空间
//指针减指针得到的绝对值是指针和指针之间元素的个数
//int main()
//{
//	int arr[10] = { 0 };
//
//	printf("%d\n", &arr[9] - &arr[0]); //9
//	return 0;
//}

//my_strlen的实现
//1.计数器，如果不是/0就count++
//2.递归
//3.指针减去指针(整型的数组实现不了，因为没有'\0'停不下来）
//
//int my_strlen(char*str)
//{
//	//int i = 0;
//	//char* start = str;
//	//do 
//	//{
//	//	str++;
//	//	//&str[i];
//	//} while (*str); //'\0'的ASCALL值是0； 
//	//return str ;
//
//	char* start = str;
//	while (*str)
//	{
//		str++;
//	}
//	return str - start;
//}
//int main() 
//{
//	char arr[] = "abcdef";
//	//int arr[] = { 2,1,3,4,6};
//	int len = my_strlen(arr);
//
//	printf("%d\n", len);
//	return 0;
//
//}

//4指针的关系运算
//for (vp = &values[N_VALUES]; vp > &values[0];)
//{
//	*--p = 0;
//}

//代码化简，将代码修改如下：
//for (vp = &values[N_VALUES - 1]; vp >= &values[0]; vp--)
//{
//	*vp = 0;
//}
//实际在绝大部分的编 译器上是可以顺利完成任务的，然而我们还是应该避免这样写，因为标准并不保证它可行。
//标准规定：
//允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。

//5.指针和数组 
//
//数组和指针不是一回事
// 数组是一块连续的空间
// 指针是存放地址的变量
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%p\n", arr);//00F3E14
//	printf("%p\n", &arr[0]);//00F3E14
//	//打印出的地址相同说明数组名arr表示数组中的首地址。
//
//	//数组名表示首元素的地址有两个例外：
//	//1.sizeof(数组名),数组名表示整个数组，计算的是整个数组的大小
//	//2.&数组名，数组名表示整个数组，取出的是整个数组的地址
//	//    
//	printf("%d\n", sizeof(arr));//40，这里数组名表示的就是整个数组
//	return 0;
//}

//数组是可以通过指针的方式来访问的
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p = arr;
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	int ret = 0;
	for (i = 0; i < sz; i++)
	{
		ret = *(p + i);//p+i,就表示下标为i的元素，加1跳过一个整型，加2跳过两个整型，加3跳过三个整型
		printf("%d ", ret);//可以证明数组在内存中是连续存放的
	}
	return 0;
}

