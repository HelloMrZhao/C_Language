#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//1.表达式求值 
//表达式求值的顺序一部分是由操作符的优先级和结合性决定。
//同样。有些表达式的操作数在求值的过程中可能需要转换为其它类型

//1>隐式类型转换
//C的整型算数运算总是至少以缺省型的精度来进行的。
//为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为-整型提升。
//int main()
//{
//	char c1 = 3; //c1是char类型的1个字节，只有8个比特位
//	//000000000000000000000000000000000000011 - 3
//	//00000011 - c1
//	char c2 = 127;
//	//000000000000000000000000000000001111111 - 127
//	//01111111 - c2
//	char c3 = c1 + c2;
//	//高位补位,整型提升
//	//000000000000000000000000000000000000011 - c1
//	//000000000000000000000000000000001111111 - c2
//	//计算c1+c2
//	//000000000000000000000000000000010000010 -  
//	//10000010 - c3
//	//111111111111111111111111111111110000010（补码）
//	//100000000000000000000000000000001111110（原码）
//	//-126
//	printf("%d\n", c3);  
//	//
//	return 0;
//}
//如何进行整体提升？ --整型提升是按照变量的数据类型的符号来提升的
//负数数提升时高位补1，正数数提升时高位补0
//char是有符号的
//char 到底是signed char还是unsigned char是取决于编译器的，但是大部分编译器是signed char

//int main()
//{
//	char a = 0xb6; //10110110
//	short b = 0xb600;
//	int c = 0xb60000;
//
//	if (a == 0xb6)
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb60000)
//		printf("c");
//
//	return 0;
//}


//整型提升
int main()
{
	char c = 1;
	printf("%u\n", sizeof(c)); //1
	printf("%u\n", sizeof(+c)); //4 +有符号就相当于进行了运算，所以发生了整型提升
	printf("%u\n", sizeof(-c)); //4
	return 0;
}

//2.算术转换 
//如果某个操作符的各个操作数属于不同类型，那么除非其中一个操作数转换为另一个操作数的类型，否则操作就无法进行。
//下面的层次体系称为寻常算数转换。转换顺序是底层的向上层转换
// 这些大于等于整型的这种类型在计算的时候他采用的是算数转换
//long double
//double
//float
//unsing long int
//long int
//unsigned int
//int
//这些转换一般都是隐式发生的，例：
//float f = 3.14;
//int num = f;//隐式转换，会有精度丢失

//3.操作符的属性：
//复杂表达式的求值有三个影响因素。
//1.操作符的优先级
//2.操作符的结合性
//3.是否控制求值顺序
//两个相邻的操作符先执行哪一个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。

//1>.优先级
int main()
{
	int a = 10;
	int b = 20;
	//相邻两个操作符才讨论优先级
	int c = a + b * 5;//*乘号的优先级高，所以先算乘法在算加法
	return 0;

}

//2>.结合性
int main()
{
	int a = 10;
	int b = 20;
	//当相邻两个操作符优先级相同时，先执行哪一个取决于他的结合性
	//加法的结合性是L-R从左向右结合，所以先算a+b在算+5
	int c = a + b + 5;
	return 0;
}

//3>.是否控制求值顺序
//例：
//&& 逻辑与-控制逻辑顺序，如果左边的表达式为假，那么右边就不在进行计算，这影响了表达式的求值顺序
//|| 逻辑或-控制逻辑顺序，如果左边的表达式为真，那么右边就不在进行计算，这影响了表达式的求值顺序
//？：条件操作符rexp1?rexp2:rexp3,表达式1如果为真，表达式3不计算；如果表达式1如果为假，表达式2不计算
//, 逗号，逗号表达式的优先级是最底的-控制逻辑顺序，表达式从左向右依次计算，整个表达式的结果取决于最后一个表达式的结果