#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//1.操作符：

//1>算数操作符
//2>移位操作符
//3>位操作符
//4>赋值操作符
//5>单目操作符
//6>关系操作符
//7>逻辑操作符
//8>条件操作符
//9>逗号表达式
//10>下标引用、函数调用和结构成员


//1>算数操作符：+ - * / %
//int main()
//{
//	//除得到得是商
//	//float a = 3 / 2; //1,除号两端如果都是操作数，那么执行的 就是整数除法
//	//float a = 3 / 2.0; //1.5,除号两边必须要有一个小数结果才能算出小数。
//	//printf("%f\n", a);
//
//	//取模得到的是余数,取模预算必须都是整型
//	int a = 9 % 2;
//	printf("%d\n", a); //1
//
//	return 0;
//}

//2>移位操作符
//<< 左移操作符
//>> 右移操作符
//移位操作符的操作数只能是整数。
//左移右移操作符操作的是二进制位

//int main()
//{
//	//整数的二进制表示有三种：
//	//原码
//	//反码
//	//补码
//	//正整数的原码反码补码是相同的
//	//负整数反码，原码符号位不变，其它位按位取反。反码加1就是补码
//	//补码数值位取反加1可以得到原码
//	int a = 5; //5：0101
//	int b = a << 1; //1010--10
//	printf("%d\n",a);
//	printf("%d\n",b);
//	return 0;
//}

//右移：
//算数右移：右边丢弃，左边补原符号位
//逻辑右移：右边丢弃，左边补0
//当前编译器在右移时采用算数运算
//到底是算数运算还是逻辑运算是取决于编译器的
//对于位移运算符，不要移动负数位
//int main()
//{
//	//int a = 5;
//	//int b = a >> 1;
//	//printf("%d\n", b);//2
//
//	int a = -5;
//	int b = a >> 1;
//	printf("%d\n", b);//-3
//	return 0;
//}

//3>位操作符
// & -- 按位（2进制位）与
// | -- 按位（2进制位）或
// ^ -- 按位（2进制位）异或 
// 注：他们的操作数必须是整数
//0异或任何数都等于它本身
//int main()
//{
//	//int a = 3;     //0000000000000000000000000000000000000000011 ->  3的补码
//	//int b = -5;    //1111111111111111111111111111111111111111011 -> -5的补码
//	//int c = a & b; //0000000000000000000000000000000000000000011 
//	//printf("%d\n", c);
//
//	//异或运算符可以用来交换两个数
//	int a = 3;
//	int b = 5;
//	printf("a=%d b=%d\n", a, b);
//	//int tmp = a;
//	//a = b;
//	//b = tmp;
//	
//	//不使用变量的情况下交换两个变量：
//	////方法一：
//	//a = a + b;
//	//b = a - b;
//	//a = a - b;
//
//	//方法二：
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;
//
//	//a = 3  011  110  110  101  5
//	//b = 5  101  101  011  3
//	//	   110  011  101  
//	printf("a=%d b=%d\n", a, b);
//	return 0;
//}

//4.求一个整数存储在内存中的二进制中1的个数
//5
//000000000000000000000000000000101
//000000000000000000000000000000001 
//int main()
//{
//	int num = 0;
//	scanf("%d", &num);
//	int i = 0;
//	int count = 0;
//	for(i = 0; i < 32; i++)
//	{
//		if ((num >> i) & 1 == 1)
//			count++;
//	}
//	printf("%d\n", count);
//	return 0;
//}


//复合赋值符 --- +=  -=  *=  /=  %=  >>= <<=  &=  |=  ^=
//int main()
//{
//	int a = 0;
//	a = a + 2;
//	a += 2;
//
//	a = a >> 1;
//	a >>= 1;
//
//	a = a & 4;
//	a&= 4;
//
//	return 0;
//}


//5>单目操作符
//!      -逻辑反操作符
//-      -负值
//+      -正值
//&      -取地址
//sizeof -操作数的类型长度（以字节为单位）
//~      -对一个数的二进制按位取反
//--     -前置、后置--
//++     -前置、后置++
//*      -间接访问操作符（解引用操作符）
//(类型)  -强制转换类型

//C语言在C99之前 没有表示真假的类型
//C99之后引入了布尔类型
//#include <stdbool.h> //如果一个编译器支持这个头文键，则说明此编译器支持布尔类型
//int main()
//{
//	_Bool flag1 = true; //表示真
//	_Bool flag2 = false; //表示假
//	//bool flag1 = true; //表示真
//	if (flag1)
//	{
//		printf("hehe\n");
//	}
//	//c语言中0表示假，非0表示真
//	int num = 0;
//	if (num)
//	{
//		printf("num=%d\n", num);
//	}
//	if (!num)//判断num为假，执行后续操作
//	{
//		printf("!num=%d\n", num);
//	}
//	if (num == 0)
//	{
//		printf("%d\n", num);
//	}
//	return 0;
//}

//&取地址操作符，就是取出谁在内存中的地址
//*解引用操作符（简介访问操作符）
//struct S  //struct结构体变量
//{
//	char name[20];
//	int age;
//};
//
//int main()
//{
//	int a = 10;
//	//int* pa = &a; //pa中存的是a的地址
//	//*&a =>a;
//	//如果想通过pa找到a就间接访问
//	//*pa,通过pa中存的地址找到它所指向的对象，例：
//	//*pa = 20;//* - 解引用操作符
//	printf("a=%d\n", a); //a = 20;
//	int arr[10] = { 0 };
//	&arr; //取出数组的地址，数组的地址应该放到【数组指针】中去 
//	
//	struct S s = { 0 };
//	struct S* ps = &s;
//}

//sizeof是一个操作符
//计算类型创建的变量所占的内存的大小，单位是字节
//sizeof不能在main函数以外其它函数中计算类型创建的变量所占的内存的大小
//int main()
//{
//	int a = 10;
//	printf("%zd\n", sizeof(a)); //4
//	printf("%zd\n",sizeof a); //4,因为sizeof是一个操作符所以可以不加括号。
//	printf("%zd\n", sizeof(int)); //4
//	//%zd强制转化为整形的格式输出符
//
//	int arr[10] = { 0 };
//	printf("%zd\n", sizeof(arr));
//	 
//	int b = 10;
//	short s = 0;
//	printf("%zd\n", sizeof(s = b + 2)); //2
//	//sizeof()中的表达式不参与计算
//	//test.c--->编译--->链接--->test.exe,sizeof是在编译器期间处理的，所以sizeof()中的表达式不参与计算
//	printf("%zd\n", s); //0
//	return 0;
//}

//char* 是4或8个字节
// char 是1个字节
//int* 是4或8个字节
//int 是4个字节

//6.~ 对一个数的二进制按位取反
//int main()
//{
//	int a = 0;
//	printf("%d\n", ~a);
//	//
//	//00000000000000000000000000000000000000000000000 //0的补码
//	//11111111111111111111111111111111111111111111111 //取反后
//	//10000000000000000000000000000000000000000000001 //原码-->-1 
//
//	int b = 11;
//	//00000000000000000000000000000000000000000001011
//	//00000000000000000000000000000000000000000000100
//	b |= (1 << 2);
//	printf("%d\n", b);//15
//
//	//00000000000000000000000000000000000000000001111//1
//	//11111111111111111111111111111111111111111111011//2
//	//00000000000000000000000000000000000000000000100//3,将3按位取反得到2
//	b &= (~(1 << 2));
//	printf("%d\n", b);
//
//}

//while (scanf("%d", &n) != EOF)
//{
//	//......
//	//scanf()读取失败的时候，返回EOF
//	EOF-----> -1
//}
//scanf("%d", &n)等价于EOF
//while(~scanf("%d", &n))//所以可以终止循环，
//2.表达式求值  

//int main()
//{
//	int a = 3;
//	//++a相当于a = a+1;
//	//int b = ++a;//前置++，先++，后使用,a = a+1,b = a
//	int c = a++;//先使用，后++ .//b = a,a=a+1
//	//printf("%d\n", b); //4
//	printf("%d\n", ++a); //4
//
//	return 0;
//}

//(类型)  -强制转换类型
//int main()
//{
//	int a = (int)3.14;
//	printf("%d\n", a);
//	return 0;
//}

//7.关系操作符 >  >=  <  <=  !=(用于测试“不相等”)  ==（用于测试“相等”）  
//两个字符串不能用等号来判断是否相等
//strcmp - 专门用来比较字符串的大小，比较的是对应位置上字符的大小，不是比较长度 

//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	i = a++ && ++b && d++; //对于并且操作符来说，左边如果为假，右边就不用算了。
//	i = a++ || ++b || d++;//对于或操作符，左边如果为真，那么右边就不用在算了。 
//	printf("a = %d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);
//}

//8>条件操作符
//exp1 ? exp2 : exp3
//如果exp1为真，表达式exp2执行,exp2的结果是整个表达式的结果
//如果exp1为假，表达式exp3执行,exp3的结果是整个表达式的结果
//例：
//int main()
//{
//	int a = 0;
//	int b = 0;
//
//	if (a > 5)
//		b = 3;
//	else
//		b = -3;
//	return 0;
//}
//相当于：b = (a >5 ？ 3 ： -3）；

//使用条件表达式实现找两个数中的较大值：
//int main()
//{
//	int a = 10;
//	int b = 30;
//	int max = 0;
//	max = (a > b ? a : b);
//	printf("%d\n", max);//30
//	return 0;
//}

//9>逗号表达式
//exp1,exp2,exp3,....expN
//逗号表达式，就是用逗号隔开的多个表表达式。
//逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果
//代码1：
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b, a = b + 10, a, b = a + 1); //13
//	printf("%d\n", c);
//	printf("a=%d\nb=%d\n", a, b);
//	return 0;
//}
//
////代码2：
//if (a = b + 1, c = a / 2, d > 0)
//
////代码3：
//a = get_val();
//count_val(a);
//while (a > 0)
//{
//	//业务处理
//	a = get_val();
//	count_val(a);
//}
//
////如果使用逗号表达式，改写：
//while (a = get_val(), count_val(a), a > 0)
//{
//	//业务处理
//}

//10   >下标引用、函数调用和结构成员
//1>下标引用操作符
//int main()
//{
//	int arr[10] = { 0 };
//	//
//	arr[4] = 5;//[] 就是小标引用操作符
//	//arr和4是[]的两个操作数
//
//	//arr[4] <==> *(arr+4) <==> *(4+arr) <==> 4[arr]//这就说明[]只是一个操作符，arr和4是[]的两个操作数
//	return 0;
//}

//2>函数调用操作符：
//int Add(int x, int y)
//{
//	return x + y;
//}
//int main()
//{
//	Add(2, 3);//()函数调用操作符，操作数就是Add,2,3
//	return 0;
//}

//3>访问一个结构的成员
#include <string.h>
struct Stu
{
	char name[20];
	int age;
	float score;

};

void print1(struct Stu ss)
{
	printf("%s %d %f\n", ss.name, ss.age, ss.score);
}

void print2(struct Stu* ps)//用指针来实现
{
	printf("%s %d %f\n", (*ps).name, (*ps).age, (*ps).score);
	//因为ps指向s所以简引用ps（*ps)就等于s.
}

void print3(struct Stu* ps)
{
	printf("%s %d %f\n", ps->name, ps->age, ps->score);
}
//结构体指针->成员名

int main()
{
	struct Stu s = { "张三",26,90.5f };
	strcpy(s.name, "张三丰");
	//scanf("%s", s.name);

	s.age = 30;
	s.score = 96;
	print1(s);//方法一
	print2(&s);//方法二 (不够简便)
	print3(&s);//方法三
	//修改结构体中变量的相关信息
	return 0;
} 